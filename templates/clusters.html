<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FlaskApp</title>

    <script src="/static/vue.global.js"></script>
    <link rel="stylesheet" href="/static/bulma.min.css" />

</head>
<body>


    <style>
        /* Optional: Make columns take full height */
        html, body {
            height: 100%;
            padding: 2em;
        }
        
        /* Light mode (default) */
        @media (prefers-color-scheme: light) {
            html, body {
                background-color: #f5f5f5;
                color: #4a4a4a;
            }
        }
        
        /* Dark mode */
        @media (prefers-color-scheme: dark) {
            html, body {
                background-color: #1a1a1a;
                color: #dbdbdb;
            }
            .table {
                background-color: #242424;
                color: #dbdbdb;
            }
            .table thead th {
                background-color: #2a2a2a;
                color: #dbdbdb;
                border-color: #363636;
            }
            .table tbody tr {
                background-color: #242424;
                border-color: #363636;
            }
            .table.is-striped tbody tr:nth-child(even) {
                background-color: #2a2a2a;
            }
            .table.is-hoverable tbody tr:hover {
                background-color: #363636 !important;
            }
            .table td, .table th {
                border-color: #363636;
                color: #dbdbdb;
            }
            .button.is-info {
                background-color: #3298dc;
                color: #fff;
            }
            .button.is-info:hover {
                background-color: #2793da;
            }
            .button.is-warning {
                background-color: #ffdd57;
                color: rgba(0,0,0,.7);
            }
            .button.is-warning:hover {
                background-color: #ffdb4a;
            }
            .is-size-3 {
                color: #dbdbdb;
            }
            a {
                color: #3273dc;
            }
            a:hover {
                color: #485fc7;
            }
            .radio {
                color: #dbdbdb;
            }
            .facet-title {
                color: #dbdbdb;
            }
        }
        
        .check{
            width: 20px;
            height: 20px;
        }

        tr{
            cursor: pointer;
        }
        svg {
            width: 30px;
            height: 30px;
            margin: 0 auto;
            margin-right: 1em;
        }
        .save-cluster{
            position: absolute;
            top: 1em;
            right: 1em;
        }

        label.radio {
            margin-right: 1em;
        }
        .facet-title{
            display: inline-block;
            font-weight: bold;
            margin-right: 1em;
        }


/*********** Baseline, reset styles ***********/
input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  background: transparent;
  cursor: pointer;
  width: 100%;
}

/* Removes default focus */
input[type="range"]:focus {
  outline: none;
}

/******** Chrome, Safari, Opera and Edge Chromium styles ********/
/* slider track */
input[type="range"]::-webkit-slider-runnable-track {
  background-color: #bdeeff;
  border-radius: 0.5rem;
  height: 2rem;
}

@media (prefers-color-scheme: dark) {
  input[type="range"]::-webkit-slider-runnable-track {
    background-color: #363636;
  }
}

/* slider thumb */
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; /* Override default look */
  appearance: none;
  margin-top: -8px; /* Centers thumb on the track */
  background-color: #000000;
  border-radius: 1rem;
  height: 3rem;
  width: 1.5rem;
  z-index: 2;
}

@media (prefers-color-scheme: dark) {
  input[type="range"]::-webkit-slider-thumb {
    background-color: #dbdbdb;
  }
}

input[type="range"]:focus::-webkit-slider-thumb {
  outline: 3px solid #000000;
  outline-offset: 0.125rem;
}

@media (prefers-color-scheme: dark) {
  input[type="range"]:focus::-webkit-slider-thumb {
    outline: 3px solid #dbdbdb;
  }
}

/*********** Firefox styles ***********/
/* slider track */
input[type="range"]::-moz-range-track {
  background-color: #bdeeff;
  border-radius: 0.5rem;
  height: 2rem;
}

@media (prefers-color-scheme: dark) {
  input[type="range"]::-moz-range-track {
    background-color: #363636;
  }
}

/* slider thumb */
input[type="range"]::-moz-range-thumb {
  background-color: #000000;
  border: none; /*Removes extra border that FF applies*/
  border-radius: 1rem;
  height: 3rem;
  width: 1.5rem;
}

@media (prefers-color-scheme: dark) {
  input[type="range"]::-moz-range-thumb {
    background-color: #dbdbdb;
  }
}

input[type="range"]:focus::-moz-range-thumb{
  outline: 3px solid #000000;
  outline-offset: 0.125rem;
}

@media (prefers-color-scheme: dark) {
  input[type="range"]:focus::-moz-range-thumb {
    outline: 3px solid #dbdbdb;
  }
}



    </style>



    <div id="app">

        <!-- Save notification -->
        <div v-if="showSaveNotification" class="notification is-success" 
             :style="{ opacity: notificationOpacity, transition: 'opacity 0.5s ease-in-out' }"
             style="position: fixed; bottom: 20px; right: 20px; z-index: 1000; min-width: 250px;">
            <button @click="showSaveNotification = false" class="delete"></button>
            Cluster saved successfully!
        </div>


        
        <div style="margin-bottom: 1em;">
            <div>Showing: ${currentIndex}$ of ${Object.keys(viewClusters).length-1}$</div>
            <div>
                <span class="facet-title">Facet Options:</span>
<div class="radios" style="display: inline-block;">
  <label class="radio">
    <input type="radio" name="rsvp" value="all" v-model="facetValue" @change="refreshView()" />
    All
  </label>
  <label class="radio">
    <input type="radio" name="rsvp" value="excluded" v-model="facetValue" @change="refreshView()" />
    Has Excluded Clusters
  </label>
  <label class="radio" v-for="lang in availableLanguages" :key="lang">
    <input type="radio" name="rsvp" :value="'lang-' + lang" v-model="facetValue" @change="refreshView()" />
    ${lang}$
  </label>

  
</div>                
                
                

            </div>
        </div>
        <div style="position: relative;">
            <input type="range" class="slider is-fullwidth" min="1" :max="Object.keys(viewClusters).length-1" v-model="currentIndex" @input="activeCluster = viewClusters[allClustersKeys[currentIndex]].data; combineData(); console.log(activeCluster)" />

        </div>
        <div class="is-size-3" v-if="activeCluster && activeCluster.orginal">${activeCluster.orginal.title}$</div>
        <div class="is-size-3" v-if="activeCluster && activeCluster.orginal">${activeCluster.orginal.author}$</div>

        <div>
            <table class="table is-striped is-hoverable is-fullwidth">
                <thead>
                    <tr>
                        <th></th>
                        <th>Title</th>
                        <th>Author</th>
                        <th>Language</th>
                        <th>Type/Source</th>
                        <th>Details</th>
                        <th>Link</th>
                    </tr>
                </thead>
                <tbody>
                    <tr v-for="(item, index) in activeClusterDisplay" :key="getItemKey(item)" >
                        <td>
                            <input v-model="item.included" :id="getItemKey(item)" class="check" type="checkbox" @change="saveCluster(); isSaved = false;">
                        </td>
                        

                        <td @click="toggleCheckbox(getItemKey(item))">${getDisplayTitle(item)}$</td>
                        <td @click="toggleCheckbox(getItemKey(item))">${getDisplayAuthor(item)}$</td>

                        <td @click="toggleCheckbox(getItemKey(item))">${getDisplayLanguage(item)}$</td>
                        <td @click="toggleCheckbox(getItemKey(item))">${getItemType(item)}$</td>
                        <td @click="toggleCheckbox(getItemKey(item))">${getItemDetails(item)}$</td>
                        <td><a :href="getItemLink(item)" target="_blank">${getItemLinkText(item)}$</a></td>

                    </tr>                 
                </tbody>
            </table>
        </div>

    </div>

    
    <script>

        const { createApp } = Vue

        let vue = createApp({
          delimiters: ["${", "}$"],
          // for standalone
          compilerOptions: {
            delimiters: ["${", "}$"]
          },          
          
          
          data() {
            return {

                allClusters: {{data.get('clusters', {})|tojson}},
                viewClusters: {{data.get('clusters', {})|tojson}},
                allClustersKeys: {},
                activeCluster:{},
                activeClusterDisplay: [],
                currentIndex:1,
                maxIndex:0,
                facetValue: 'all', // Default value for the facet
                isSaved:true,
                showSaveNotification: false,
                notificationOpacity: 1,
              
            }
          },
          
          computed: {
            // Extract unique languages from all cluster data
            availableLanguages() {
                const languages = new Set();
                
                for (let [key, cluster] of Object.entries(this.allClusters)) {
                    // Check languages in included items
                    if (cluster.data && cluster.data.cluster) {
                        cluster.data.cluster.forEach(item => {
                            const lang = this.getDisplayLanguage(item);
                            if (lang && lang !== 'Unknown') {
                                languages.add(lang);
                            }
                        });
                    }
                    
                    // Check languages in excluded items
                    if (cluster.data && cluster.data.cluster_excluded) {
                        cluster.data.cluster_excluded.forEach(item => {
                            const lang = this.getDisplayLanguage(item);
                            if (lang && lang !== 'Unknown') {
                                languages.add(lang);
                            }
                        });
                    }
                }
                
                return Array.from(languages).sort();
            }
          },

          methods:{

            setVal(itemKey){
                // Find the item in activeClusterDisplay and toggle its included value
                const item = this.activeClusterDisplay.find(item => this.getItemKey(item) === itemKey);
                if (item) {
                    item.included = !item.included;
                    this.isSaved = false;
                    // Auto-save after change
                    this.saveCluster();
                }
            },


            toggleCheckbox(itemKey) {
                // Find the item in activeClusterDisplay and toggle its included value
                const item = this.activeClusterDisplay.find(item => this.getItemKey(item) === itemKey);
                if (item) {
                    item.included = !item.included;
                    this.isSaved = false;
                    // Auto-save after change
                    this.saveCluster();
                }
            },
            
            // Data structure abstraction methods
            getItemKey(item) {
                // Generate unique key for different item types
                if (item.ht_bib_key) {
                    return item.ht_bib_key; // HathiTrust format
                } else if (item.uri) {
                    return item.uri; // Library of Congress format
                } else if (item.id) {
                    return item.id; // Generic format
                } else {
                    // Fallback: create key from available data
                    return `${item.title || 'unknown'}_${item.author || 'unknown'}_${Math.random()}`;
                }
            },
            
            getDisplayTitle(item) {
                // Extract title from different formats
                if (item.title) {
                    return item.title; // HathiTrust format
                } else if (item.aLabel) {
                    return item.aLabel; // Library of Congress format
                } else if (item.volumeInfo && item.volumeInfo.title) {
                    // Google Books format
                    let title = item.volumeInfo.title;
                    if (item.volumeInfo.subtitle) {
                        title += ': ' + item.volumeInfo.subtitle;
                    }
                    return title;
                } else if (item.mainTitle) {
                    return item.mainTitle; // OCLC/WorldCat format
                } else if (item.name) {
                    return item.name; // Generic format
                } else {
                    return 'Unknown Title';
                }
            },
            
            getDisplayAuthor(item) {
                // Extract author from different formats
                if (item.author) {
                    return item.author; // HathiTrust format
                } else if (item.more && item.more.contributors && item.more.contributors.length > 0) {
                    return item.more.contributors[0]; // Library of Congress format
                } else if (item.volumeInfo && item.volumeInfo.authors && item.volumeInfo.authors.length > 0) {
                    return item.volumeInfo.authors.join(', '); // Google Books format
                } else if (item.creator) {
                    return item.creator; // OCLC/WorldCat format
                } else if (item.contributor) {
                    return item.contributor; // Generic format
                } else {
                    return 'Unknown Author';
                }
            },
            
            getDisplayLanguage(item) {
                // Extract language from different formats
                if (item.lang) {
                    return item.lang; // HathiTrust format
                } else if (item.itemLanguage) {
                    return item.itemLanguage; // OCLC/WorldCat format
                } else if (item.language) {
                    return item.language; // Library of Congress enriched format
                } else if (item.volumeInfo && item.volumeInfo.language) {
                    return item.volumeInfo.language; // Google Books format
                } else if (item.languages && Array.isArray(item.languages) && item.languages.length > 0) {
                    return item.languages[0]; // Multiple languages, take first
                } else if (item.more && item.more.language) {
                    return item.more.language; // Alternative LC format
                } else if (item.more && item.more.languages && Array.isArray(item.more.languages) && item.more.languages.length > 0) {
                    return item.more.languages[0]; // Multiple languages in more object
                } else {
                    return 'Unknown';
                }
            },
            
            getItemType(item) {
                // Identify the source/type of the item
                if (item.ht_bib_key) {
                    return 'HathiTrust';
                } else if (item.uri && item.uri.includes('id.loc.gov')) {
                    return 'Library of Congress';
                } else if (item.uri && item.uri.includes('viaf.org')) {
                    return 'VIAF';
                } else if (item.uri && item.uri.includes('worldcat.org')) {
                    return 'WorldCat';
                } else if ((item.uri && item.uri.includes('googleapis.com')) || item.id) {
                    return 'Google Books';
                } else {
                    return 'Unknown Source';
                }
            },
            
            getItemDetails(item) {
                // Show relevant metadata details
                const details = [];
                
                // Responsibility statement (from Library of Congress and OCLC)
                if (item.responsibilityStatement) {
                    details.push(`Responsibility: ${item.responsibilityStatement}`);
                } else if (item.statementOfResponsibility) {
                    details.push(`Responsibility: ${item.statementOfResponsibility}`);
                }
                
                // Publication year
                if (item.pub_date) {
                    details.push(`Year: ${item.pub_date}`);
                } else if (item.originDate) {
                    details.push(`Year: ${item.originDate}`);
                } else if (item.publicationDate) {
                    details.push(`Year: ${item.publicationDate}`); // OCLC format
                } else if (item.volumeInfo && item.volumeInfo.publishedDate) {
                    details.push(`Year: ${item.volumeInfo.publishedDate}`);
                } else if (item.provisionActivities && item.provisionActivities.length > 0 && item.provisionActivities[0].date) {
                    details.push(`Year: ${item.provisionActivities[0].date}`);
                }
                
                // Identifiers
                if (item.identifiers && item.identifiers.length > 0) {
                    const firstId = item.identifiers[0];
                    details.push(`${firstId.type}: ${firstId.value}`);
                } else if (item.volumeInfo && item.volumeInfo.industryIdentifiers && item.volumeInfo.industryIdentifiers.length > 0) {
                    // Google Books identifiers
                    const firstId = item.volumeInfo.industryIdentifiers[0];
                    details.push(`${firstId.type}: ${firstId.identifier}`);
                } else if (item.isbns && item.isbns.length > 0) {
                    // OCLC ISBNs
                    details.push(`ISBN: ${item.isbns[0]}`);
                }
                
                // OCLC number for HathiTrust and OCLC records
                if (item.oclc) {
                    details.push(`OCLC: ${item.oclc}`);
                } else if (item.oclcNumber) {
                    details.push(`OCLC: ${item.oclcNumber}`);
                }
                
                // Format for OCLC
                if (item.generalFormat) {
                    details.push(`Format: ${item.generalFormat}`);
                }
                
                // Access rights for HathiTrust
                if (item.rights) {
                    details.push(`Rights: ${item.rights}`);
                }
                
                // Publisher info
                if (item.provisionActivities && item.provisionActivities.length > 0) {
                    const provision = item.provisionActivities[0];
                    if (provision.agent || provision.place) {
                        details.push(`Pub: ${provision.agent || ''} ${provision.place || ''}`.trim());
                    }
                } else if (item.volumeInfo && item.volumeInfo.publisher) {
                    details.push(`Pub: ${item.volumeInfo.publisher}`);
                }
                
                // Page count for Google Books
                if (item.volumeInfo && item.volumeInfo.pageCount) {
                    details.push(`Pages: ${item.volumeInfo.pageCount}`);
                }
                
                return details.join('; ') || 'No details available';
            },
            
            getItemLink(item) {
                // Generate appropriate link for the item
                if (item.htid) {
                    return `https://catalog.hathitrust.org/Record/${item.htid}`;
                } else if (item.ht_bib_key) {
                    return `https://catalog.hathitrust.org/Record/${item.ht_bib_key}`;
                } else if (item.oclcNumber) {
                    // OCLC/WorldCat - construct URL from OCLC number
                    return `https://worldcat.org/oclc/${item.oclcNumber}`;
                } else if (item.uri) {
                    return item.uri;
                } else if (item.selfLink) {
                    // Google Books direct link
                    return item.selfLink;
                } else if (item.id) {
                    // Google Books - construct URL from ID
                    return `https://www.googleapis.com/books/v1/volumes/${item.id}`;
                } else if (item.url) {
                    return item.url;
                } else {
                    return '#';
                }
            },
            
            getItemLinkText(item) {
                // Generate appropriate link text
                if (item.htid || item.ht_bib_key) {
                    return 'HathiTrust';
                } else if (item.oclcNumber) {
                    return 'WorldCat';
                } else if (item.uri && item.uri.includes('id.loc.gov')) {
                    return 'id.loc.gov';
                } else if (item.uri && item.uri.includes('viaf.org')) {
                    return 'VIAF';
                } else if (item.uri && item.uri.includes('worldcat.org')) {
                    return 'WorldCat';
                } else if (item.uri && item.uri.includes('googleapis.com')) {
                    return 'Google Books';
                } else if (item.id) {
                    return 'Google Books';
                } else {
                    return 'View';
                }
            },

            combineData() {
                // Combine cluster and cluster_excluded into single array with included flag
                const combined = [];
                
                if (!this.activeCluster) return;
                
                // Add items from cluster with included: true
                if (this.activeCluster.cluster && Array.isArray(this.activeCluster.cluster)) {
                    this.activeCluster.cluster.forEach(item => {
                        combined.push({
                            ...item,
                            included: true
                        });
                    });
                }
                
                // Add items from cluster_excluded with included: false
                if (this.activeCluster.cluster_excluded && Array.isArray(this.activeCluster.cluster_excluded)) {
                    this.activeCluster.cluster_excluded.forEach(item => {
                        combined.push({
                            ...item,
                            included: false
                        });
                    });
                }
                
                this.activeClusterDisplay = combined;
            },
            
            updateDataFromDisplay() {
                // Convert activeClusterDisplay back to original data format
                const newCluster = [];
                const newClusterExcluded = [];
                
                this.activeClusterDisplay.forEach(item => {
                    // Create a copy without the included property
                    const itemCopy = { ...item };
                    delete itemCopy.included;
                    
                    if (item.included) {
                        newCluster.push(itemCopy);
                    } else {
                        newClusterExcluded.push(itemCopy);
                    }
                });
                
                // Update the activeCluster object
                this.activeCluster.cluster = newCluster;
                this.activeCluster.cluster_excluded = newClusterExcluded;
                
                // Also update the main clusters data
                const currentKey = this.allClustersKeys[this.currentIndex];
                if (this.viewClusters[currentKey]) {
                    this.viewClusters[currentKey].data.cluster = newCluster;
                    this.viewClusters[currentKey].data.cluster_excluded = newClusterExcluded;
                }
                if (this.allClusters[currentKey]) {
                    this.allClusters[currentKey].data.cluster = newCluster;
                    this.allClusters[currentKey].data.cluster_excluded = newClusterExcluded;
                }
            },
            
            getFormattedData() {
                // Returns a new object with the updated cluster arrays based on activeClusterDisplay
                const formattedData = { ...this.activeCluster };
                
                const newCluster = [];
                const newClusterExcluded = [];
                
                this.activeClusterDisplay.forEach(item => {
                    // Create a copy without the included property
                    const itemCopy = { ...item };
                    delete itemCopy.included;
                    
                    if (item.included) {
                        newCluster.push(itemCopy);
                    } else {
                        newClusterExcluded.push(itemCopy);
                    }
                });
                
                formattedData.cluster = newCluster;
                formattedData.cluster_excluded = newClusterExcluded;
                console.log("Formatted Data:", formattedData);
                return formattedData;
            },
            
            async saveCluster() {
                // Get the formatted data and send to backend
                let dataToSave = this.getFormattedData();
                const currentKey = this.allClustersKeys[this.currentIndex];
                
                dataToSave = {
                    data: dataToSave,
                    cluster_id: currentKey
                };
                
                try {
                    const response = await fetch('/api/local/save_cluster', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(dataToSave)
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('Cluster auto-saved successfully:', result);
                        this.isSaved = true;
                        
                        // Show success notification
                        this.showSaveNotification = true;
                        this.notificationOpacity = 1;
                        
                        // Start fade out after 2 seconds
                        setTimeout(() => {
                            this.notificationOpacity = 0;
                            // Hide completely after fade completes
                            setTimeout(() => {
                                this.showSaveNotification = false;
                                this.notificationOpacity = 1; // Reset for next time
                            }, 500);
                        }, 2000);
                        
                        // Update the stored data
                        this.updateDataFromDisplay();
                        
                    } else {
                        console.error('Failed to auto-save cluster:', response.status);
                        alert('Failed to auto-save cluster. ' + response.status + ' ' + response.statusText);
                    }
                } catch (error) {
                    console.error('Error auto-saving cluster:', error);
                }
            },

            refreshView(){
                console.log("Refreshing view with facet value: ", this.facetValue);
                
                this.viewClusters = JSON.parse(JSON.stringify(this.allClusters)); // Deep copy to avoid reference issues


                if (this.facetValue === 'all') {
                    // do nothing
                } else if (this.facetValue === 'excluded') {
                    this.viewClusters = {};
                    for (let [key, value] of Object.entries(this.allClusters)) {
                        if (value.data.cluster_excluded.length > 0) {
                            this.viewClusters[key] = value;
                        }
                    }
                } else if (this.facetValue.startsWith('lang-')) {
                    const lang = this.facetValue.split('-')[1];
                    this.viewClusters = {};
                    for (let [key, value] of Object.entries(this.allClusters)) {
                        if (value.data.cluster.some(item => this.getDisplayLanguage(item) === lang) || value.data.cluster_excluded.some(item => this.getDisplayLanguage(item) === lang)) {
                            this.viewClusters[key] = value;
                        }
                    }
                }



                let counter=0
                for (let [key, value] of Object.entries(this.viewClusters)) {
                    counter++
                    this.allClustersKeys[counter] = key;
                }

                this.currentIndex = 1; // Reset to the first cluster
                this.activeCluster = this.viewClusters[this.allClustersKeys[this.currentIndex]].data;
                this.combineData(); // Combine the data for display

                this.maxIndex = Object.keys(this.viewClusters).length - 1;

            }

            

          },

          mounted() {
            this.refreshView();
            console.log("Mounted: ", this.viewClusters[this.allClustersKeys[1]]);
            this.activeCluster = this.viewClusters[this.allClustersKeys[1]].data;
            this.combineData();
            // this.activeCluster = this.allClusters[this.allClustersKeys[this.currentIndex]].data;
          },

          created(){  




          }
        }).mount('#app')


    </script>




</body>
</html>